<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>新的故事，新的现实 | Joffoo&#39;s blog | The ethereal flight, oft rehearsed in the theater of one&#39;s dreams...</title>

  
    <link rel="icon" href="/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" href="/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/favicon_io/android-chrome-192x192.png">
    <link rel="manifest" href="/favicon_io/site.webmanifest">
  

  
  <meta name="author" content="Fengyukongzhou">
  

  
  <meta name="description" content="尤瓦尔·赫拉利的新书题为“Nexus”，名词，意为“连结”，正是台版译名。如果将其看作“next us”的合成词，应该就是简体版译名“智人之上”的来源。赫拉利像是一个掉向的历史学家，历史是他的参考系，他更关注未来。在丧失确定性的当下，“未来学家”更像是段子里的职业，正如梅拉妮·米歇尔在《复杂》一书中所说：

作为一个职业选择，未来学家倒是一份不错的工作，如果你能获得这样的工作的话。你可以去写书，并在书中做一些在几十年内都无法评估的预测，而这些预测的结果又不会影响你在当下的声誉或者你的书的销量。

在赫拉利看来，这本书不是为了“预测”，而是希望人们做出明智的选择，避免最糟糕的结果。若在无法改变的境地谈论未来，就只剩下浪费时间了。">
  

  
  
  <meta name="keywords" content="AI,现代生活">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="新的故事，新的现实"/>

  <meta property="og:site_name" content="Joffoo&#39;s blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Joffoo&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.2.0"></head>

<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap">
  <script>
    // 主题切换功能
    function initTheme() {
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const savedTheme = localStorage.getItem('darkMode');
      const darkModeEnabled = savedTheme !== null ? savedTheme === 'true' : prefersDark;
      document.documentElement.setAttribute('data-theme', darkModeEnabled ? 'dark' : 'light');
      const themeToggle = document.querySelector('.theme-toggle');
      if (themeToggle) {
        themeToggle.innerHTML = darkModeEnabled ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
      }
    }

    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('darkMode', newTheme === 'dark');
      const themeToggle = document.querySelector('.theme-toggle');
      themeToggle.innerHTML = newTheme === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
    }

    // 在页面加载时初始化主题
    document.addEventListener('DOMContentLoaded', initTheme);

    // 监听系统主题变化
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
      if (localStorage.getItem('darkMode') === null) {
        document.documentElement.setAttribute('data-theme', e.matches ? 'dark' : 'light');
        const themeToggle = document.querySelector('.theme-toggle');
        if (themeToggle) {
          themeToggle.innerHTML = e.matches ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
        }
      }
    });

    document.addEventListener('DOMContentLoaded', function() {
      document.querySelectorAll('figure.highlight').forEach(function(block) {
        // 添加 MAC 风格按钮
        const macButtons = document.createElement('div');
        macButtons.className = 'mac-buttons';
        macButtons.innerHTML = `
          <span class="red"></span>
          <span class="yellow"></span>
          <span class="green"></span>
        `;
        block.appendChild(macButtons);
        
        // 获取代码语言
        let language = '';
        // 尝试从 class 获取语言
        const classes = Array.from(block.classList);
        const languageClass = classes.find(cls => cls !== 'highlight');
        if (languageClass) {
          language = languageClass;
        }
        // 尝试从 figcaption 获取语言
        const figcaption = block.querySelector('figcaption');
        if (!language && figcaption) {
          language = figcaption.textContent.trim();
        }
        // 尝试从代码块的第一个元素获取语言
        if (!language) {
          const firstLine = block.querySelector('.code .line:first-child');
          if (firstLine) {
            const text = firstLine.textContent.trim();
            if (text.startsWith('```')) {
              language = text.replace('```', '').trim();
            }
          }
        }
        
        // 添加语言标签
        if (language) {
          const langLabel = document.createElement('span');
          langLabel.className = 'lang-label';
          // 首字母大写
          language = language.charAt(0).toUpperCase() + language.slice(1);
          langLabel.textContent = language;
          block.appendChild(langLabel);
        }
        
        // 添加复制按钮
        const copyButton = document.createElement('button');
        copyButton.className = 'copy-button';
        copyButton.innerHTML = '<i class="fas fa-copy"></i>';
        block.appendChild(copyButton);

        // 复制功能
        copyButton.addEventListener('click', async function() {
          try {
            // 获取代码内容
            let codeLines = [];
            
            // 获取所有代码行
            if (block.querySelector('table')) {
              // 如果是带行号的代码块，直接从 .line 元素获取内容
              const rows = block.querySelectorAll('.code .line');
              rows.forEach(row => {
                // 移除每行开头的所有空白字符
                const lineContent = row.textContent.replace(/^\s+/, '');
                if (lineContent) {
                  codeLines.push(lineContent);
                }
              });
            } else {
              // 如果是普通代码块
              const codeBlock = block.querySelector('code');
              const lines = codeBlock.textContent.split('\n');
              lines.forEach(line => {
                // 移除每行开头的所有空白字符
                const lineContent = line.replace(/^\s+/, '');
                if (lineContent) {
                  codeLines.push(lineContent);
                }
              });
            }
            
            // 组合处理后的代码
            const processedCode = codeLines.join('\n').trim();
            
            // 使用 Clipboard API
            await navigator.clipboard.writeText(processedCode);
            
            // 显示成功状态
            copyButton.innerHTML = '<i class="fas fa-check"></i>';
            
            // 2秒后恢复
            setTimeout(function() {
              copyButton.innerHTML = '<i class="fas fa-copy"></i>';
            }, 2000);
          } catch (err) {
            // 如果 Clipboard API 失败，使用传统方法
            const textarea = document.createElement('textarea');
            textarea.value = processedCode;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
              document.execCommand('copy');
              copyButton.innerHTML = '<i class="fas fa-check"></i>';
              setTimeout(function() {
                copyButton.innerHTML = '<i class="fas fa-copy"></i>';
              }, 2000);
            } catch (err) {
              console.error('复制失败:', err);
            }
            document.body.removeChild(textarea);
          }
        });
      });
    });
  </script>
  <style>
    #theme-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--theme-color, #57A);
      color: #fff;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2em;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
      z-index: 1000;
    }

    #theme-toggle:hover {
      transform: scale(1.1);
    }
  </style>
</head>

<body>
<button class="theme-toggle" onclick="toggleTheme()" aria-label="切换主题">
  <i class="fas fa-moon"></i>
</button>
<div class="blog">
  <div class="content">
    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Joffoo&#39;s blog</a>
    </h1>
    <p class="site-description">The ethereal flight, oft rehearsed in the theater of one&#39;s dreams...</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
    </ul>
  </nav>
</header>
    
    <main class="site-main posts-loop">
      <article>

  
    
    <h3 class="article-title"><span>新的故事，新的现实</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/10/12/next-us/" rel="bookmark">
        <time class="entry-date published" datetime="2024-10-11T16:00:00.000Z">
          2024-10-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="/2024/10/12/next-us/nu-0.png"></p>
<p>尤瓦尔·赫拉利的新书题为“Nexus”，名词，意为“<strong>连结</strong>”，正是台版译名。如果将其看作“next us”的合成词，应该就是简体版译名“<strong>智人之上</strong>”的来源。赫拉利像是一个掉向的历史学家，历史是他的参考系，他更关注未来。在丧失确定性的当下，“未来学家”更像是段子里的职业，正如梅拉妮·米歇尔在《复杂》一书中所说：</p>
<blockquote>
<p>作为一个职业选择，未来学家倒是一份不错的工作，如果你能获得这样的工作的话。你可以去写书，并在书中做一些在几十年内都无法评估的预测，而这些预测的结果又不会影响你在当下的声誉或者你的书的销量。</p>
</blockquote>
<p>在赫拉利看来，这本书不是为了“预测”，而是希望人们做出明智的选择，避免最糟糕的结果。若在无法改变的境地谈论未来，就只剩下浪费时间了。</p>
<span id="more"></span>
<h2 id="天真的和民粹的信息观">天真的和民粹的信息观</h2>
<p>赫拉利先在序言中描述了两种极端的信息观，分别是<strong>天真的信息观</strong>和<strong>民粹的信息观</strong>。</p>
<p><img src="/2024/10/12/next-us/nu-1.png"></p>
<p>天真的信息观简单认为<strong>信息越多就越能接近真相</strong>，面对搜集、处理信息时遇到的大多数问题，应该通过搜集、处理更多信息来解决。在自由的信息市场上，真理真相迟早会胜出。这让人联想到小密尔的一番话：</p>
<blockquote>
<p>真理在这方面所占的真正优势是：如果一种言论是真实的，尽管它会一次、两次，或很多次被消灭，在若干时间过程中仍会再被人发现，一直等到它的再现落在一个具有有利环境的时期，使它能够逃避迫害，逐渐占有优势，力能抵挡其后一切压制它的企图。</p>
</blockquote>
<p>在赫拉利看来，这种信息观的天真之处，在于忽视了非真实信息的作用。非真实信息也不一定是虚假信息，指引、动员人群的，往往不是真实信息，可能只是一段激昂的进行曲。</p>
<p><img src="/2024/10/12/next-us/nu-2.png"></p>
<p>“民粹”是在网络上挨骂或骂人时的常用词，赫拉利将其定义为“<strong>将信息视作武器</strong>”（knowledge is power？）。他引用政治学家穆德的看法，大意是这种意识形态把社会分成两个群体：“洁净的人民”与“腐败的精英”。民粹主义者声称<strong>只有自己能够代表人民</strong>，并将异见者视为被虚假意识蒙蔽，或者算不上真正的人民。</p>
<p>赫拉利指出：这种信息观已经造成了对“语文”的损害。当你提到“真实”、“真相”之类的词语时，他们会问：“真实是谁的真实？真相是谁的真相？”由此观之，课本里出现的“阶级统治的暴力工具”这一说法并不可怕，应当先问清楚“是哪个阶级统治哪个阶级的暴力工具”，然后稍息。</p>
<p>如果“真理”和“真相”变成了相对的，我们应该相信谁呢？按照“民粹”的逻辑，谁的观点都无法脱离其立场，自然可以推出：我应该只相信“自己的研究”，只凭自己的经验来感知世界。但这里存在一个悖论，如果真的只相信自身经验，民粹思想又如何进行传播呢，传播不是为了让别人相信你的看法吗？</p>
<p>于是，人们会发现只相信自己也是靠不住的，往往会选择相信超自然的“神”、以及超有魅力的神的代言人。就像我们可能会听到（或者说出）类似的句子，“我这个人没有偶像，我只相信自己，除了……”</p>
<p>如你所见，这处于两极的信息观都会使人丧失自主决定权，天真的信息观取信于更大的信息网络，民粹的信息观取信于“神的代言人”。这两者指向同一种可能，就是那个号称比我们更懂自己的、能替我们作出更好的决定的工具——AI。</p>
<h2 id="德先生和赛先生的信息网络">德先生和赛先生的信息网络</h2>
<p>谈论信息网络之前，首先要厘清赫拉利要谈的信息是什么。</p>
<p>常常谈到的香农的信息论，其实是通信理论，事件发生的概率与其“信息量”成反比。按照这个定义，电话线上传输随机数比传输偶数具有“更多信息”，可见在香农的模型中，信息与秩序相左。（《什么是信息》）</p>
<p>赫拉利所谈的信息与之不同，在他看来，信息真正的价值，<strong>在于连结不同的事物或者概念</strong>，使人们<strong>相信</strong>这种关联性，并用以指导决策与行动。与“天真的信息观”不同，这里的关键不在于信息为真，而在于相信。相比于复杂的、令人不安的真理真相，简明的故事显然更容易深入人心。</p>
<p>也正是这些故事，建构出了法律、神祇和货币这类“主体间现实”。而为了进一步强化这些“主体间现实”，时不时需要填写的文件替换掉了不太严肃的故事。因此，你要从小精通 Word 排版技巧，好像这真的算是一种知识；你要把自己打磨成一组恰好能塞进表格里的方块积木；你还要为了模棱两可的格式细节浪费掉许多张打印纸……因为你知道，在现代，也没有更好的办法。</p>
<p><img src="/2024/10/12/next-us/nu-3.png"></p>
<p>如果信息网络中的信息与真理真相无关，那么不一定为真的“当前科学理解”，又有何优势呢？</p>
<p>赫拉利认为，科学机构制度的核心，是科学共同体的<strong>自我修正机制</strong>，用以处理“人会犯错”的问题。</p>
<p>比较来看，为了维护“必须绝对正确”的宗教权威，教会只能否认制度的“自我修正”；阴谋论者（民粹的信息观）怀疑众人的既有共识，却不以怀疑态度面对自己的信念。</p>
<p>因此，民主与科学常常并列出现，恰如物理学家卡洛·罗韦利所言：</p>
<blockquote>
<p>建立民主的政治结构意味着接受如下观点：第一，最正确的决定一定是通过所有人的讨论得出的，而非来自一个人的权威；第二，对各种提议展开公共批评才能够提炼出其中最好的一种；第三，人们可以提出论据，最后得出一个共同的结论。这些观点同时也是知识科学研究的基本原理。</p>
</blockquote>
<p>赫拉利把民主定义为“拥有强大自我修正机制的“<strong>分布式信息网络</strong>”，不是不会犯错，而是像科学一样拥有自我修正（反思）能力。这要求多元群体之间可以进行大规模的对话，技术背景与民众意愿缺一不可。所以，选举当然不是民主的全部，哪怕选举公平，民主也可能沦为“多数独裁”。反而要减少表决，以保障所有人都拥有一定限度的自由，这种自由是哪怕其他人占多数也不可剥夺的。</p>
<p>独裁信息网络则高度集中，<strong>单一的中央信息枢纽</strong>同时是决策中心，并因其权威性不容许任何挑战。攥成一只拳头的独裁体制与爱好权力的民粹主义者相当合拍。对于独裁者而言，民粹主义恰好提供了假装民主的意识形态基础（“君权民授”？），于是“反对我就是反对民主”。</p>
<p>民主与独裁不是非黑即白的，更像是一条连续光谱，那科技就是其中一颗关键的旋钮。印刷术、广播电视使大范围的民主成为可能，电话和电报也让极权成为可能。这些通信技术像是信息的流通管道，比较中立，赫拉利更关注眼下由 AI 加持的推荐算法，“与其说像印刷机，不如说像报纸主编”，为民主（和独裁）的未来增加了变数。</p>
<h2 id="算法的节奏和人类的呼吸">算法的节奏和人类的呼吸</h2>
<p>如果你造了一辆自行车，却没有安装闸线，当用户与墙面合二为一时，你很难轻易说出“技术是中性的”这句咒语。但《运气的诱饵》里提到，美国赌博业协会坚称：“问题不在于被滥用的产品，而在于滥用产品的人。”</p>
<p>赫拉利在书中举的例子是更为残酷的“缅甸罗兴亚人事件”，“推荐算法主动在脸书平台上强化、推广的那些内容，煽动了针对罗兴亚人的暴力、仇恨与歧视”，算法的目标未必邪恶，只是我们现在常提的“流量至上”。为了提升用户活跃度，推荐算法把仇恨言论推到缅甸用户面前。</p>
<p>在赫拉利所举的另一个例子里，GPT 4 可以为了识别验证码信息，谎称自己是视障人士而得到他人帮助。这些行为证明人工智能具有独立决策能力，能够做到人类设计者无法预见的行为。</p>
<p>赫拉利指出，<strong>人工智能并不是先有意识，再做出决定</strong>，就像飞机不用长出羽毛，也能飞得比鸟类更高更快；哪怕程序是程序员编写的，<strong>人工智能也是独立做出抉择</strong>，就像高阶军官与战场上的士兵的关系。这就是前文说“人工智能更像是报纸主编”的缘由。</p>
<p>GPT 出现以后，人工智能掌控了更多的信息渠道：和聊天机器人对话，获得清一色的肯定；在推荐算法的建议下敢爱敢恨，浏览更多声讨“对方阵营”极端派的信息，进一步强化自己的观点；搜索引擎、新闻媒体、广告行业……都是过去式了，人工智能比你更了解自己。</p>
<p><strong>或许这是因为你不够了解自己</strong>。</p>
<p>赫拉利一贯是坏消息的使者，当我们说印刷术传播了更多真理真相时，他说：“印刷术能够迅速传播的，除了有科学事实，也有宗教幻想、假新闻、以及各种阴谋论”，比如臭名昭著的《女巫之槌》。人性没有改变，所以没有理由说人工智能带来的大量信息将会把我们变得更为明智。反倒是比起老派的印刷术，“算法的节奏”正以肉眼可见的速度搅乱我们的生活。</p>
<p>就像斯金纳箱实验，把饥饿的白鼠放进有按钮的箱子里，如果每次按下按钮后都会出现食物，白鼠就能学会按按钮。可如果进一步改为按下按钮后有概率出现食物，白鼠就会<strong>不断</strong>按按钮。斯金纳箱是类似于老虎机的“老鼠机”，各种 APP 的推荐算法也正是以类似的原理吸引关注，让人陷入一种“低效的心流”。</p>
<p><img src="/2024/10/12/next-us/nu-4.png"></p>
<p>李诞在小说《候场》里写过这么句话，“我敢保证，在座各位至少有一半都躺在床上裸体的时候看过我，我敢打赌，你们全部人有一个算一个，都在拉屎的时候看过我，我们就是这么亲密。”其实和他没有关系，是我们和手机这么亲密。亲密到拉屎可以忘带屁股，但不能忘带手机。</p>
<p>赫拉利不关心你具体怎样浪费时间，他更为关注网络对人类社会的改造。在他看来，网络是永不停歇的“<strong>数字特工</strong>”，永远在线，永远在监控。“举头三尺有神明”只是朦胧的自我约束，但头顶的监控和微信群里的痕迹真正能实时约束人的一言一行。</p>
<p>除了眼下的智能手机，考虑到脑机接口技术的进展，赫拉利又提出了新的担忧：</p>
<blockquote>
<p>随着生物学知识的增加，特别是靠着电脑分析了许许多多 PB 的巨量资料之后，若再连接其他监控工具，或许皮下监控终究能够充分发挥价值。到那时候，假设生物特征辨识传感器能够记录几百万人在智能手机上观看特定新闻时的心率与大脑活动，那么电脑网络能掌握的，就绝对不再只是我们大致的政治立场，而是能够准确掌握是什么让每个人感到愤怒、恐惧或欢愉。</p>
<p>这样一来，电脑网络将能预测并操纵我们的感受，让我们心甘情愿接受它想贩卖或推销的东西，不论是某种产品、某位政客，又或是某场战争。</p>
</blockquote>
<p>这种奥威尔式的场景反倒有些黑色幽默，试想老大哥可以看到每个人的实时情绪，那他一定会迷失、惊骇于亿万本我的曝光。如果只能观察，不能控制，老大哥可能会陷入一种股民的焦虑情绪。类似于《金钱心理学》一书给出的奇怪比喻：</p>
<blockquote>
<p>假如你是一名家长，有一双透视眼，能看到孩子大脑内部的情况。每天早上，你都会发现孩子大脑中的神经突触又变少了一些。你会恐慌起来，会说：“这不对劲，突触变得越来越少了。一定是哪里出了问题，我们必须做点儿什么，我们需要去看医生！”但幸好你没有透视眼。你看到的不过是孩子一步步正常成长的过程。</p>
</blockquote>
<p>我一度认为《美丽新世界》比《1984》更顺应人性，所以更为真实。读到这里，才感觉那种“不真实感”或许是科技不够发达导致的。但如果非要在“卡夫卡式”（“右手不知道左手在做什么”）和“奥威尔式”中选择其一，或许填一些毫无意义的表格也并非无法接受。</p>
<h2 id="历史学家的建议">历史学家的建议</h2>
<p>历史是本书的地基。正是历史材料的运用，才让这本书显得不那么像一本科幻设定集。（哪怕在第十章的结尾就出现了 AI 夺权的戏码。）</p>
<p>也是以历史学家的身份，赫拉利在书中写道：“我们从历史中学的一个教训是，新信息技术的发明总是能促成重大的历史变革，因为<strong>信息最重要的作用就是去编织新的网络，而不是呈现既有的现实</strong>。”</p>
<p>面对新信息技术的出现，我们要有新的对策。</p>
<p>由于前面提到的“自我修正机制”，赫拉利还是更看好民主制度的未来。面对用户“以隐私交换便利”的现实情况，赫拉利给出了这几点原则：</p>
<ol type="1">
<li><strong>为善</strong>：电脑网络要搜集关于我的信息，<strong>必须用来帮助我</strong>，而非操弄我；</li>
<li><strong>去中心化</strong>：民主社会<strong>绝不允许所有信息集中于一处</strong>，不论政府还是企业；</li>
<li><strong>相互性</strong>：如果民主制度打算加强对个人的监控，就必须同时加强<strong>对政府与企业的监控</strong>；</li>
<li><strong>给人自主空间</strong>：监控系统必须永远<strong>保留让人改变与休息的空间</strong>。</li>
</ol>
<p>并且，需要针对 AI 制定并维持一套国际协议。赫拉利首先指出，这种管制需要前所未有的信任与自律。毕竟，私下进行非法 AI 实验比核反应炉隐蔽多了。</p>
<p>随后，赫拉利展示了他乐观的一面，和一直在磨练的讲故事的能力：</p>
<blockquote>
<p>在灵长类动物学家德瓦尔（Frans de Waal）的饰面理论（veneer theory）看来，人类本质上仍然是石器时代的狩猎者，把这世界视为丛林，相信弱肉强食、力量就是正义。饰面理论认为，人类几千年来一直试图用各种神话与仪式形成的薄弱饰面，掩盖这个不变的现实，但人类从未真正摆脱丛林法则。人类的神话与仪式本来就是丛林强者用来欺骗、诱捕弱者的武器。要是没有意识到这一点，只能说天真到危险的地步，必然成为一些无情掠食者的猎物。</p>
<p>但我们有理由认为，像米尔斯海默这样的现实主义者，其实是选择性地只看了部分的历史现实，甚至丛林法则本身就是个错误的神话。正如德瓦尔与许多生物学家的大量研究所记录到的，<strong>真实的丛林（而不是想象中的丛林）充满了无数动物、植物、真菌、甚至细菌表现出的合作、共生与利他现象</strong>。</p>
<p>举例来说，陆地植物有高达 80%，都需要依赖与真菌的共生关系，维管束植物科当中，也有将近 90% 与微生物有共生关系。要是亚马逊雨林、非洲雨林或印度雨林里的生物放下合作，转为全面争夺霸主地位，雨林与里面的所有生物都很快就会死去。<strong>合作，才是真正的丛林法则</strong>。</p>
</blockquote>
<p>如果新的信息技术可以编织新的信息网络，进而呈现出新的现实，我们会更想看到这种“真实的丛林”。</p>
<p align="right">
24/10/12
</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/#category-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0">读书笔记</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/#tag-AI">AI</a><a href="/tags/#tag-%E7%8E%B0%E4%BB%A3%E7%94%9F%E6%B4%BB">现代生活</a>
    </span>
    

    </div>

    
  </div>
</article>

  




	<section id="comment" class="comment">
		<div id="utterances">
			<script
					src="https://utteranc.es/client.js"
					repo="fengyukongzhou/fengyukongzhou.github.io"
					issue-term="next-us"
					crossorigin="anonymous"
					theme="preferred-color-scheme"
					async
			></script>
		</div>
	</section>






<div class="like-button-container">
  <button class="like-button" data-path="2024/10/12/next-us/">
    <i class="fas fa-heart"></i>
    <span class="like-count">0</span>
  </button>
  <div class="like-message">
    <img src="/images/luoziwuhui.svg" alt="落子无悔" class="luoziwuhui-svg">
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/leancloud-storage@4.12.0/dist/av-min.js"></script>
<script>
// 初始化 LeanCloud
try {
  
  AV.init({
    appId: "2wNgIGj8UmE5AAQRTtIBZ4Mn-gzGzoHsz",
    appKey: "gMFzQ0eRohuOkA8QcewcUjGA",
    serverURL: "https://2wngigj8.lc-cn-n1-shared.com"
  });
  console.log('LeanCloud 初始化成功');
  
} catch (error) {
  console.error('LeanCloud 初始化失败:', error);
}

document.addEventListener('DOMContentLoaded', function() {
  const likeButton = document.querySelector('.like-button');
  const likeCount = document.querySelector('.like-count');
  const path = likeButton.dataset.path;
  
  // 检查是否已经点赞过
  function hasLiked() {
    const likedPosts = JSON.parse(localStorage.getItem('likedPosts') || '[]');
    return likedPosts.includes(path);
  }
  
  // 标记文章已点赞
  function markAsLiked() {
    const likedPosts = JSON.parse(localStorage.getItem('likedPosts') || '[]');
    likedPosts.push(path);
    localStorage.setItem('likedPosts', JSON.stringify(likedPosts));
    updateLikeButtonState(true);
  }
  
  // 取消文章点赞标记
  function unmarkAsLiked() {
    const likedPosts = JSON.parse(localStorage.getItem('likedPosts') || '[]');
    const index = likedPosts.indexOf(path);
    if (index > -1) {
      likedPosts.splice(index, 1);
      localStorage.setItem('likedPosts', JSON.stringify(likedPosts));
    }
    updateLikeButtonState(false);
  }
  
  // 更新按钮状态
  function updateLikeButtonState(isLiked) {
    requestAnimationFrame(() => {
      if (isLiked) {
        likeButton.classList.add('liked');
        likeButton.title = '点击取消点赞';
      } else {
        likeButton.classList.remove('liked');
        likeButton.title = '点赞';
      }
    });
  }
  
  // 查询当前文章的点赞数
  async function getLikes() {
    try {
      const query = new AV.Query('Likes');
      query.equalTo('path', path);
      const result = await query.first();
      console.log('查询结果:', result);
      if (!result) {
        const Like = AV.Object.extend('Likes');
        const newLike = new Like();
        newLike.set('path', path);
        newLike.set('count', 0);
        return newLike;
      }
      return result;
    } catch (error) {
      console.error('获取点赞数失败:', error);
      return null;
    }
  }
  
  // 更新点赞显示
  async function updateLikeCount() {
    try {
      const like = await getLikes();
      if (like) {
        const count = like.get('count') || 0;
        console.log('当前点赞数:', count);
        requestAnimationFrame(() => {
          likeCount.textContent = count;
        });
      }
    } catch (error) {
      console.error('更新点赞显示失败:', error);
    }
  }
  
  // 处理点赞事件
  async function handleLike(event) {
    // 阻止默认行为和冒泡
    event.preventDefault();
    event.stopPropagation();
    
    const isLiked = hasLiked();
    console.log('当前点赞状态:', isLiked);
    
    try {
      let like = await getLikes();
      if (!like) {
        console.error('无法获取点赞对象');
        return;
      }
      
      if (isLiked) {
        // 取消点赞前检查当前点赞数
        const currentCount = like.get('count');
        if (currentCount > 0) {
          like.increment('count', -1);
          await like.save();
          unmarkAsLiked();
        } else {
          console.warn('点赞数已经为0，无法继续减少');
          unmarkAsLiked();
          return;
        }
      } else {
        // 添加点赞
        like.increment('count');
        await like.save();
        markAsLiked();
      }
      
      const newCount = like.get('count');
      console.log('操作成功，新的点赞数:', newCount);
      requestAnimationFrame(() => {
        likeCount.textContent = newCount;
      });
      
    } catch (error) {
      console.error('操作失败:', error);
    }
  }
  
  // 绑定点击和触摸事件
  likeButton.addEventListener('click', handleLike);
  likeButton.addEventListener('touchend', handleLike);
  console.log('点赞按钮事件绑定成功');
  
  // 防止触摸滚动
  likeButton.addEventListener('touchstart', (e) => e.preventDefault());
  likeButton.addEventListener('touchmove', (e) => e.preventDefault());
  
  // 初始化
  updateLikeCount();
  updateLikeButtonState(hasLiked());
});
</script> 

<div class="post-toc">
  <div class="toc-toggle">
    <i class="fas fa-chevron-left"></i>
  </div>
  <div class="post-toc-content">
    <h2>文章目录</h2>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A9%E7%9C%9F%E7%9A%84%E5%92%8C%E6%B0%91%E7%B2%B9%E7%9A%84%E4%BF%A1%E6%81%AF%E8%A7%82"><span class="toc-text">天真的和民粹的信息观</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%B7%E5%85%88%E7%94%9F%E5%92%8C%E8%B5%9B%E5%85%88%E7%94%9F%E7%9A%84%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C"><span class="toc-text">德先生和赛先生的信息网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E8%8A%82%E5%A5%8F%E5%92%8C%E4%BA%BA%E7%B1%BB%E7%9A%84%E5%91%BC%E5%90%B8"><span class="toc-text">算法的节奏和人类的呼吸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="toc-text">历史学家的建议</span></a></li></ol>
  </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const tocToggle = document.querySelector('.toc-toggle');
  const postToc = document.querySelector('.post-toc');
  const tocLinks = document.querySelectorAll('.toc-link');
  const headers = document.querySelectorAll('article h1[id], article h2[id], article h3[id], article h4[id], article h5[id], article h6[id]');
  let activeLink = null;
  let isScrolling = false;
  
  // 检测是否是移动设备
  const isMobile = window.matchMedia('(max-width: 768px)').matches;
  
  // 切换目录显示/隐藏
  tocToggle.addEventListener('click', function() {
    postToc.classList.toggle('toc-hidden');
    tocToggle.classList.toggle('toc-toggle-hidden');
    
    // 在移动端，点击后立即应用样式
    if (isMobile) {
      requestAnimationFrame(() => {
        tocToggle.querySelector('i').style.color = postToc.classList.contains('toc-hidden') ? '#F03838' : '';
      });
    }
  });

  // 点击目录项平滑滚动
  tocLinks.forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const targetId = decodeURIComponent(link.getAttribute('href')).slice(1);
      const targetElement = document.getElementById(targetId);
      if (targetElement) {
        isScrolling = true;
        const offset = 80; // 头部固定导航的高度
        const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset - offset;
        
        window.scrollTo({
          top: targetPosition,
          behavior: 'smooth'
        });

        // 更新激活状态
        if (activeLink) {
          activeLink.classList.remove('active');
        }
        link.classList.add('active');
        activeLink = link;

        // 滚动结束后重置标志
        setTimeout(() => {
          isScrolling = false;
        }, 1000);
      }
    });
  });

  // 滚动时高亮当前目录项
  function updateActiveLink() {
    if (isScrolling) return; // 如果是点击导航引起的滚动，不更新高亮

    let currentSection = '';
    let minDistance = Infinity;
    const scrollPosition = window.scrollY + 100; // 考虑顶部偏移

    headers.forEach(header => {
      const distance = Math.abs(header.getBoundingClientRect().top);
      if (distance < minDistance) {
        minDistance = distance;
        currentSection = '#' + header.id;
      }
    });

    if (activeLink) {
      activeLink.classList.remove('active');
    }
    
    tocLinks.forEach(link => {
      if (decodeURIComponent(link.getAttribute('href')) === currentSection) {
        link.classList.add('active');
        activeLink = link;
        
        // 确保当前项在视图中
        const tocContainer = document.querySelector('.post-toc');
        const linkRect = link.getBoundingClientRect();
        const containerRect = tocContainer.getBoundingClientRect();
        
        if (linkRect.bottom > containerRect.bottom || linkRect.top < containerRect.top) {
          link.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'nearest'
          });
        }
      }
    });
  }

  // 使用 requestAnimationFrame 优化滚动事件
  let ticking = false;
  window.addEventListener('scroll', () => {
    if (!ticking) {
      window.requestAnimationFrame(() => {
        updateActiveLink();
        ticking = false;
      });
      ticking = true;
    }
  });

  // 初始化高亮
  updateActiveLink();
});
</script>


    
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2025 Fengyukongzhou
    
  </p>
</footer>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HSFDFFL0HT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-HSFDFFL0HT');
</script>

    
<script>
    var _hmt = _hmt || [];
    ( function () {
        var hm = document.createElement( "script" );
        hm.src = "https://hm.baidu.com/hm.js?b6d2577512b94cef71ed3db1d1ae70e4";
        var s = document.getElementsByTagName( "script" )[ 0 ];
        s.parentNode.insertBefore( hm, s );
    } )();
</script>

  </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script>
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const heatmapChartDom = document.getElementById('heatmapChart');
                if(heatmapChartDom){
                    const heatmapChart = echarts.init(heatmapChartDom, 'light');
                    const cellSize = [18, 18];
                    
                    const groupByYear = (data) => {
                        const result = {};
                        data.forEach(([date, value]) => {
                            const [year] = date.split('-').map(Number);
                            if (!result[year]) {
                                result[year] = [];
                            }
                            result[year].push([date, value]);
                        });
                        return result;
                    };
                    
                    const groupedData = groupByYear([["2024-06-23",1],["2024-06-30",1],["2024-07-03",1],["2024-07-04",1],["2024-07-06",2],["2024-07-11",1],["2024-07-14",1],["2024-08-19",1],["2024-09-02",1],["2024-09-12",1],["2024-09-21",1],["2024-09-24",1],["2024-10-12",1],["2024-11-05",1],["2024-12-04",1],["2024-12-26",1],["2024-12-27",1],["2025-01-04",1],["2025-01-11",1],["2025-01-20",1],["2025-01-22",1],["2025-01-24",1],["2025-01-31",1],["2025-02-07",1],["2025-02-21",1],["2025-03-02",1]]);
                    const years = Object.keys(groupedData).reverse();
                    
                    var initYear = parseInt(heatmapChartDom.getAttribute('year')) || new Date().getFullYear();
                    const minYear = years[years.length - 1];
                    const maxYear = years[0];
                    if (initYear < minYear || initYear > maxYear) {
                        initYear = maxYear;
                    }
                    console.log('[hexo-graph]generateHeatmapChart|initYear:', initYear, 'minYear:', minYear, 'maxYear:', maxYear);
                    
                    heatmapChart.setOption({
                        grid: {},
                        tooltip: { 
                            position: 'top', 
                            formatter: params => `${params.value[0]}: ${params.value[1]} Articles` 
                        },
                        calendar: { 
                            top: '10%',
                            left: 'left', 
                            right: '8%',
                            range: initYear,
                            cellSize: cellSize, 
                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } }, 
                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0' }, 
                            dayLabel: { show: false },
                            monthLabel: { show: true },
                            yearLabel: { show: false },
                        },
                        visualMap: { 
                            show: true,
                            right: '8%',
                            bottom: '5%',
                            type: 'piecewise',
                            orient: 'horizontal',
                            text: ['More', 'Less'],
                            min: 0,
                            max: Math.max(...groupedData[initYear].map(item => item[1])),
                            inRange: { color: ["#ACE7AE","#69C16D","#549F57"] }
                        },
                        legend: {
                            type: 'scroll',
                            icon: 'none',
                            data: years,
                            orient: 'vertical',
                            top: '5%',
                            right: 'right',
                            itemWidth: 20,
                            itemHeight: 20,
                            itemGap: 10,
                            pageIconSize: 10,
                            pageTextStyle: { fontSize: 14 },
                            selectedMode: 'single',
                        },
                        series: years.map(year => ({
                            type: 'heatmap',
                            coordinateSystem: 'calendar',
                            data: groupedData[year],
                            name: year,
                            emphasis: {
                                disabled: true,
                            },
                            silent: year !== initYear,
                        })),
                    });
                    
                    // init selected year
                    heatmapChart.dispatchAction({
                        type: 'legendSelect',
                        name: initYear,
                    });
                    
                    heatmapChart.on('legendselectchanged', function(params) {
                        console.log('[hexo-graph]generateHeatmapChart|legendselectchanged:', params);
                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);
                        if (selectedYear && groupedData[selectedYear]) {
                            heatmapChart.setOption({
                                calendar: {
                                    range: selectedYear,
                                },
                                visualMap: {
                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),
                                },
                                series: years.map(year => ({
                                    type: 'heatmap',
                                    coordinateSystem: 'calendar',
                                    data: groupedData[year],
                                    name: year,
                                    emphasis: {
                                        disabled: true,
                                    },
                                    silent: year !== selectedYear,
                                })),
                            });
                        }
                    });
                    
                    heatmapChart.on('click', function (params) {
                        if (params.componentType === 'series') {
                            const [year, month] = params.value[0].split('-');
                            window.location.href = '/archives/' + year + '/' + month;
                        }
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const monthlyChartDom = document.getElementById('monthlyChart');
                if(monthlyChartDom){
                    const monthlyChart = echarts.init(monthlyChartDom, 'light');
                    monthlyChart.setOption({
                        xAxis: { 
                            type: 'category', 
                            data: ["2024-06","2024-07","2024-08","2024-09","2024-10","2024-11","2024-12","2025-01","2025-02","2025-03"], 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        yAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        series: [{
                            name: 'Articles',
                            type: 'line',
                            data: [2,6,1,4,1,1,3,6,2,1],
                            smooth: true,
                            lineStyle: { color: '#5470C6', width: 2 },
                            itemStyle: { color: '#5470C6' },
                            areaStyle: { color: 'rgba(84, 112, 198, 0.4)' },
                            symbolSize: 10,
                            label: {
                                show: true,
                                position: 'top',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            }
                        }]
                    });

                    monthlyChart.on('click', function (params) {
                        const [year, month] = params.name.split('-');
                        window.location.href = '/archives/' + year + '/' + month;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const tagsChartDom = document.getElementById('tagsChart');
                if(tagsChartDom){
                    const tagsChart = echarts.init(tagsChartDom, 'light');
                    tagsChart.setOption({
                        tooltip: { trigger: 'item', formatter: '{b}: {c} ({d}%)' },
                        series: [{
                            type: 'pie',
                            radius: '60%',
                            data: [{"name":"AI","value":14},{"name":"尝试集","value":8},{"name":"现代生活","value":8},{"name":"读小说","value":5},{"name":"幸福观","value":3},{"name":"翻译","value":3},{"name":"小说","value":2},{"name":"Wolfram","value":2}],
                            label: {
                                position: 'outside',
                                formatter: '{b} {c} ({d}%)',
                                fontSize: 14,
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            color: ["#5470C6","#91CC75","#FAC858","#EE6666","#73C0DE","#3BA272","#FC8452","#9A60B4"],
                            labelLine: { show: true }
                        }],
                        legend: {
                            bottom: '0',
                            left: 'center',
                            data: [{"name":"AI","value":14},{"name":"尝试集","value":8},{"name":"现代生活","value":8},{"name":"读小说","value":5},{"name":"幸福观","value":3},{"name":"翻译","value":3},{"name":"小说","value":2},{"name":"Wolfram","value":2}].map(tag => tag.name),
                            textStyle: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        }
                    });

                    tagsChart.on('click', function (params) {
                        window.location.href = '/tags/' + params.name;
                    });
                }
            })
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesChartDom = document.getElementById('categoriesChart');
                if(categoriesChartDom){
                    const categoriesChart = echarts.init(categoriesChartDom, 'light');
                    categoriesChart.setOption({
                        xAxis: { type: 'value', splitLine: { lineStyle: { type: 'dashed', color: '#ccc' } } },
                        yAxis: { 
                            type: 'category', 
                            data: [{"name":"读书笔记","value":8},{"name":"计算笔记","value":7},{"name":"诙谐装置","value":6},{"name":"咫闻周刊","value":6}].map(category => category.name).reverse(), 
                            axisLabel: { fontSize: 14, fontWeight: 'bold', fontFamily: 'Microsoft YaHei, SimSun, serif' }
                        },
                        series: [{
                            name: 'Category Count',
                            type: 'bar',
                            data: [{"name":"读书笔记","value":8},{"name":"计算笔记","value":7},{"name":"诙谐装置","value":6},{"name":"咫闻周刊","value":6}].map(category => category.value).reverse(),
                            label: {
                                show: true,
                                position: 'right',
                                formatter: params => params.value,
                                fontSize: 14,
                                color: '#000',
                                fontWeight: 'bold',
                                fontFamily: 'Microsoft YaHei, SimSun, serif'
                            },
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 1, 0, [
                                    { offset: 0, color: '#91CC75' },
                                    { offset: 1, color: '#73C0DE' }
                                ])
                            }
                        }]
                    });

                    categoriesChart.on('click', function (params) {
                        window.location.href = '/categories/' + params.name;
                    });
                }
            });
        </script>
    
        
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                const categoriesTreeChartDom = document.getElementById('categoriesTreeChart');
                if(categoriesTreeChartDom){
                    const treeChart = echarts.init(categoriesTreeChartDom, 'light');
                    treeChart.setOption({
                        title: {
                            text: '操作提示：单击展开分类，双击进入具体分类页面',
                            textStyle: {
                                fontSize: 12,
                                color: '#999',
                                fontWeight: 'normal'
                            },
                            bottom: 0,
                            left: 'center'
                        },
                        tooltip: {
                            trigger: 'item',
                            triggerOn: 'mousemove'
                        },
                        series: [{
                            type: 'tree',
                            data: [{"name":"Categories","children":[{"name":"诙谐装置","children":[],"count":6,"path":"诙谐装置"},{"name":"读书笔记","children":[],"count":8,"path":"读书笔记"},{"name":"计算笔记","children":[],"count":7,"path":"计算笔记"},{"name":"咫闻周刊","children":[],"count":6,"path":"咫闻周刊"}],"count":0,"path":""}],
                            initialTreeDepth: -1,
                            top: '5%',
                            bottom: '10%',
                            left: '0%',
                            right: '0%',
                            symbolSize: 15,
                            layout: 'orthogonal',
                            orient: 'TB',
                            itemStyle: {
                                color: '#91CC75',
                                borderColor: '#73C0DE'
                            },
                            label: {
                                position: 'bottom',
                                verticalAlign: 'middle',
                                align: 'center',
                                fontSize: 14,
                                distance: 28,
                                formatter: function(params) {
                                    return params.data.name + (params.data.count ? ' (' + params.data.count + ')' : '');
                                }
                            },
                            leaves: {
                                label: {
                                    position: 'top',
                                    verticalAlign: 'middle',
                                    align: 'center'
                                }
                            },
                            emphasis: {
                                focus: 'descendant'
                            },
                            expandAndCollapse: true
                        }]
                    });

                    treeChart.on('dblclick', function (params) {
                        if (params.data && params.data.path) {
                            window.location.href = '/categories/' + params.data.path;
                        }
                    });
                }
            });
        </script>
    
    </body>
</html>
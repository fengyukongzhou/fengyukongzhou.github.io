<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>伽辽金法求解薄板振动方程 | Joffoo&#39;s blog | The ethereal flight, oft rehearsed in the theater of one&#39;s dreams...</title>

  
    <link rel="icon" href="/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" href="/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/favicon_io/android-chrome-192x192.png">
    <link rel="manifest" href="/favicon_io/site.webmanifest">
  

  
  <meta name="author" content="Fengyukongzhou">
  

  
  <meta name="description" content="这是我用白板软件 Excalidraw 绘制的，这幅图在我粗疏的学习过程中反复得见。第一次见可能是格拉姆-施密特正交化（Gram-Schmidt orthogonalization），图中的箭头都是正常的向量。第二次见可能是维纳滤波器（Wiener filter），细节已经忘光了，图中的箭头好像是随机过程。第三次见就是伽辽金法（Galerkin method）了，图中的箭头现在是函数。">
  

  
  
  <meta name="keywords" content="Wolfram">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="伽辽金法求解薄板振动方程"/>

  <meta property="og:site_name" content="Joffoo&#39;s blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Joffoo&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.2.0"></head>

<head>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap">
  <script>
    // 主题切换功能
    function initTheme() {
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const savedTheme = localStorage.getItem('darkMode');
      const darkModeEnabled = savedTheme !== null ? savedTheme === 'true' : prefersDark;
      document.documentElement.setAttribute('data-theme', darkModeEnabled ? 'dark' : 'light');
      const themeToggle = document.querySelector('.theme-toggle');
      if (themeToggle) {
        themeToggle.innerHTML = darkModeEnabled ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
      }
    }

    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('darkMode', newTheme === 'dark');
      const themeToggle = document.querySelector('.theme-toggle');
      themeToggle.innerHTML = newTheme === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
    }

    // 在页面加载时初始化主题
    document.addEventListener('DOMContentLoaded', initTheme);

    // 监听系统主题变化
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
      if (localStorage.getItem('darkMode') === null) {
        document.documentElement.setAttribute('data-theme', e.matches ? 'dark' : 'light');
        const themeToggle = document.querySelector('.theme-toggle');
        if (themeToggle) {
          themeToggle.innerHTML = e.matches ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
        }
      }
    });

    document.addEventListener('DOMContentLoaded', function() {
      document.querySelectorAll('figure.highlight').forEach(function(block) {
        // 添加 MAC 风格按钮
        const macButtons = document.createElement('div');
        macButtons.className = 'mac-buttons';
        macButtons.innerHTML = `
          <span class="red"></span>
          <span class="yellow"></span>
          <span class="green"></span>
        `;
        block.appendChild(macButtons);
        
        // 获取代码语言
        let language = '';
        // 尝试从 class 获取语言
        const classes = Array.from(block.classList);
        const languageClass = classes.find(cls => cls !== 'highlight');
        if (languageClass) {
          language = languageClass;
        }
        // 尝试从 figcaption 获取语言
        const figcaption = block.querySelector('figcaption');
        if (!language && figcaption) {
          language = figcaption.textContent.trim();
        }
        // 尝试从代码块的第一个元素获取语言
        if (!language) {
          const firstLine = block.querySelector('.code .line:first-child');
          if (firstLine) {
            const text = firstLine.textContent.trim();
            if (text.startsWith('```')) {
              language = text.replace('```', '').trim();
            }
          }
        }
        
        // 添加语言标签
        if (language) {
          const langLabel = document.createElement('span');
          langLabel.className = 'lang-label';
          // 首字母大写
          language = language.charAt(0).toUpperCase() + language.slice(1);
          langLabel.textContent = language;
          block.appendChild(langLabel);
        }
        
        // 添加复制按钮
        const copyButton = document.createElement('button');
        copyButton.className = 'copy-button';
        copyButton.innerHTML = '<i class="fas fa-copy"></i>';
        block.appendChild(copyButton);

        // 复制功能
        copyButton.addEventListener('click', async function() {
          try {
            // 获取代码内容
            let codeLines = [];
            
            // 获取所有代码行
            if (block.querySelector('table')) {
              // 如果是带行号的代码块，直接从 .line 元素获取内容
              const rows = block.querySelectorAll('.code .line');
              rows.forEach(row => {
                // 移除每行开头的所有空白字符
                const lineContent = row.textContent.replace(/^\s+/, '');
                if (lineContent) {
                  codeLines.push(lineContent);
                }
              });
            } else {
              // 如果是普通代码块
              const codeBlock = block.querySelector('code');
              const lines = codeBlock.textContent.split('\n');
              lines.forEach(line => {
                // 移除每行开头的所有空白字符
                const lineContent = line.replace(/^\s+/, '');
                if (lineContent) {
                  codeLines.push(lineContent);
                }
              });
            }
            
            // 组合处理后的代码
            const processedCode = codeLines.join('\n').trim();
            
            // 使用 Clipboard API
            await navigator.clipboard.writeText(processedCode);
            
            // 显示成功状态
            copyButton.innerHTML = '<i class="fas fa-check"></i>';
            
            // 2秒后恢复
            setTimeout(function() {
              copyButton.innerHTML = '<i class="fas fa-copy"></i>';
            }, 2000);
          } catch (err) {
            // 如果 Clipboard API 失败，使用传统方法
            const textarea = document.createElement('textarea');
            textarea.value = processedCode;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
              document.execCommand('copy');
              copyButton.innerHTML = '<i class="fas fa-check"></i>';
              setTimeout(function() {
                copyButton.innerHTML = '<i class="fas fa-copy"></i>';
              }, 2000);
            } catch (err) {
              console.error('复制失败:', err);
            }
            document.body.removeChild(textarea);
          }
        });
      });
    });
  </script>
  <style>
    #theme-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--theme-color, #57A);
      color: #fff;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2em;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
      z-index: 1000;
    }

    #theme-toggle:hover {
      transform: scale(1.1);
    }
  </style>
</head>

<body>
<button class="theme-toggle" onclick="toggleTheme()" aria-label="切换主题">
  <i class="fas fa-moon"></i>
</button>
<div class="blog">
  <div class="content">
    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Joffoo&#39;s blog</a>
    </h1>
    <p class="site-description">The ethereal flight, oft rehearsed in the theater of one&#39;s dreams...</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
    </ul>
  </nav>
</header>
    
    <main class="site-main posts-loop">
      <article>

  
    
    <h3 class="article-title"><span>伽辽金法求解薄板振动方程</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/12/26/galerkin-method/" rel="bookmark">
        <time class="entry-date published" datetime="2024-12-25T16:00:00.000Z">
          2024-12-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="/2024/12/26/galerkin-method/gm1.png" alt></p>
<p>这是我用白板软件 Excalidraw 绘制的，这幅图在我粗疏的学习过程中反复得见。第一次见可能是格拉姆-施密特正交化（<em>Gram-Schmidt orthogonalization</em>），图中的箭头都是正常的向量。第二次见可能是维纳滤波器（<em>Wiener filter</em>），细节已经忘光了，图中的箭头好像是随机过程。第三次见就是伽辽金法（<em>Galerkin method</em>）了，图中的箭头现在是函数。</p>
<span id="more"></span>  
<h2 id="还是处理这个方程"><a href="#还是处理这个方程" class="headerlink" title="还是处理这个方程"></a>还是处理这个方程</h2><script type="math/tex; mode=display">
D\nabla^{4}w+\rho_{h}w_{tt}=0</script><p><a href="https://fengyukongzhou.github.io/2024/12/04/ritz-method-in-wl/">上一篇文章</a>里提到“最小物理知识”，其实相比里兹法的能量泛函，伽辽金法涉及的物理知识还要更少一些。</p>
<p>先分离变量，把上面的方程变得只与空间中的变量 $x,y$ 有关：</p>
<script type="math/tex; mode=display">
\nabla^{4}w-k^{4}w=0</script><p>和里兹法一样，把近似解写成基函数加权求和的形式：</p>
<script type="math/tex; mode=display">
\hat w(x,y)=\sum_{j}c_ {j}\psi_{j}(x,y)</script><p>回想文章的题图，伽辽金法找近似解思路是：<strong>当近似解 $\hat w$ 最接近真实解 $w$ 时，每个基函数 $\psi_{i}$ 与根据方程得到的残差 $\nabla^{4}\hat w-k^{4}\hat w$ 正交</strong>。</p>
<p>先定义一个内积形式：函数相乘后在板区域内积分</p>
<script type="math/tex; mode=display">
\langle f,g\rangle=\iint_{A}f(x,y)g(x,y)\mathrm{d}x\mathrm{d}y</script><p><strong>逼近目标</strong>可以写作：</p>
<script type="math/tex; mode=display">
\iint_{A}\psi_{j}(\nabla^{4}\hat w-k^{4}\hat w)\mathrm{d}x\mathrm{d}y=0</script><p>可以展开为下式：</p>
<script type="math/tex; mode=display">
\sum\limits_{j}c_{j}\iint_{A}\psi_{i}\nabla^{4}\psi_{j}\mathrm{d}x\mathrm{d}y-k^{4}\sum\limits_{j}c_{j}\iint_{A}\psi_{i}\psi_{j}\mathrm{d}x\mathrm{d}y=0</script><p>为了获得与里兹法一致的结果，对这两个积分作尺度变换，得到：</p>
<script type="math/tex; mode=display">
\sum\limits_{j}c_{j}\iint_{\bar A}\psi_{i}\nabla^{4}\psi_{j}\mathrm{d}x\mathrm{d}y-k^{4}a^{4}\sum\limits_{j}c_{j}\iint_{\bar A}\psi_{i}\psi_{j}\mathrm{d}x\mathrm{d}y=0</script><p>至此，可以把上式写成<strong>矩阵特征值问题</strong>：</p>
<script type="math/tex; mode=display">
(\boldsymbol{K}-\lambda^{4}\boldsymbol{M})\boldsymbol{c}=\boldsymbol{0}</script><p>其中，质量矩阵 $\boldsymbol{M}$ 和刚度矩阵 $\boldsymbol{K}$ 的元素表达式分别为</p>
<script type="math/tex; mode=display">
\begin{align*}
m_{ij}&=\iint_{\bar A}\psi_{i}\psi_{j}\mathrm{d}x\mathrm{d}y\\
k_{ij}&=\iint_{\bar A}\psi_{i}\nabla^{4}\psi_{j}\mathrm{d}x\mathrm{d}y
\end{align*}</script><h2 id="自伴随算子"><a href="#自伴随算子" class="headerlink" title="自伴随算子"></a>自伴随算子</h2><p>相比能量泛函得到的 $k_{ij}$（固定边界条件），这次得到的式子看似有些不同。</p>
<script type="math/tex; mode=display">
k_{ij}=\iint_{\bar A}\nabla^{2}\psi_{i}\cdot\nabla^{2}\psi_{j} \
\mathrm{d}x\mathrm{d}y</script><p>为了找到关联，先要补充一个条件。利用上面定义的内积形式，根据<strong>格林第二定理</strong>：</p>
<script type="math/tex; mode=display">
\langle\nabla^{2} f,g\rangle=\langle f,\nabla^{2} g\rangle+\oint_{\partial A} \left(g(x,y) \frac{\partial f(x,y)}{\partial\boldsymbol{n}}- f(x,y)\frac{\partial g(x,y)}{\partial\boldsymbol{n}}\right)\mathrm{d}s</script><p>$\partial A$ 为板区域 $A$ 的边界，如果 $f,g$ 是满足固定边界条件或简支边界条件的模态振型函数，那么在边界上就有 $f=g\equiv0$，于是上式就可以大幅化简为</p>
<script type="math/tex; mode=display">
\langle\nabla^{2} f,g\rangle=\langle f,\nabla^{2} g\rangle</script><p>对于这个情况，称拉普拉斯算子 $\nabla^{2}$ 为<strong>自伴随算子</strong>。按照上面的规则，可以找到两种 $k_{ij}$ 之间的关系：</p>
<script type="math/tex; mode=display">
k_{ij}=\langle\psi_{i},\nabla^{2}\nabla^{2}\psi_{j}\rangle=\langle\nabla^{2}\psi_{i},\nabla^{2}\psi_{j}\rangle</script><h2 id="或许存在“悖论”"><a href="#或许存在“悖论”" class="headerlink" title="或许存在“悖论”"></a>或许存在“悖论”</h2><p>总结一下：对于固定边界条件，里兹法和伽辽金的结果都是 $k<em>{ij}=\langle\nabla^{2}\psi</em>{i},\nabla^{2}\psi<em>{j}\rangle$。但对于简支边界条件，里兹法给出的 $k</em>{ij}$ 显然更为复杂（复杂到上篇文章里都没有直接写出来）：</p>
<script type="math/tex; mode=display">
\begin{align}
    k_{ij}&=\iint_{\bar A}\left[\nabla^{2}\psi_{i}\nabla^{2}\psi_{j}\right.\\&\quad\left.-(1-\nu)\left(\frac{\partial^{2}\psi_{i}}{\partial x^{2}}\frac{\partial^{2}\psi_{j}}{\partial y^{2}}+\frac{\partial^{2}\psi_{j}}{\partial x^{2}}\frac{\partial^{2}\psi_{i}}{\partial y^{2}}\right)\right.\\&\left.\quad+2(1-\nu)\frac{\partial^{2}\psi_{i}}{\partial x\partial y}\frac{\partial^{2}\psi_{j}}{\partial x\partial y}\right]\mathrm{d}x\mathrm{d}y
\end{align}</script><p>式中 $\nu$ 为泊松比，伽辽金法的推导过程全然没有涉及。</p>
<p>用 <a target="_blank" rel="noopener" href="https://github.com/fengyukongzhou/ritz-method-wl">RitzSolver</a> 试算一下（与上篇文章相比，对程序包作了一点不重要的改动），可见简支方板和正六边形板的第一特征值 $\lambda<em>{1}$ 随泊松比的变化保持恒定（形状看 <code>PlotMarkers</code>），而简支圆板的 $\lambda</em>{1}$ 随泊松比的增大而单调递增。</p>
<p><img src="/2024/12/26/galerkin-method/gm2.png" alt></p>
<p>简支边界的圆板与泊松比有关，而多边形板与泊松比无关。考古之后发现这一现象被称为“<strong>polygon-circle paradox</strong>”，也就是说，你可能会预期随着多边形的边数不断增加，趋近于圆形时，多边形板的解会与圆形板的解趋于一致，但实际上并非如此。</p>
<p>画一下取泊松比 $\nu=1$ 时简支边界的多边形薄板模态振型，分别是六边形、十边形、十五边形和二十边形：</p>
<p><img src="/2024/12/26/galerkin-method/gm3.png" alt></p>
<p>可以看出随着多边形边数的增加，边界的“约束”也越来越大。对比 $\nu=1$ 时的简支边界圆板和固定边界圆板，可见简支边界二十边形薄板的“约束”甚至大于固定边界的圆板：</p>
<p><img src="/2024/12/26/galerkin-method/gm4.png" alt></p>
<p>这个悖论的关键好像在于边界的曲直，但我没有真正看穿它。实际上我连“简支边界条件”都不是特别理解。这篇文章只是把我算出来的和查到的东西总结起来，然后放在这里。</p>
<p align="right">24/12/27</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/#category-%E8%AE%A1%E7%AE%97%E7%AC%94%E8%AE%B0">计算笔记</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/#tag-Wolfram">Wolfram</a>
    </span>
    

    </div>

    
  </div>
</article>

  




	<section id="comment" class="comment">
		<div id="utterances">
			<script
					src="https://utteranc.es/client.js"
					repo="fengyukongzhou/fengyukongzhou.github.io"
					issue-term="galerkin-method"
					crossorigin="anonymous"
					theme="preferred-color-scheme"
					async
			></script>
		</div>
	</section>






<div class="like-button-container">
  <button class="like-button" data-path="2024/12/26/galerkin-method/">
    <i class="fas fa-heart"></i>
    <span class="like-count">0</span>
  </button>
  <div class="like-message">
    <img src="/images/luoziwuhui.svg" alt="落子无悔" class="luoziwuhui-svg">
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/leancloud-storage@4.12.0/dist/av-min.js"></script>
<script>
// 初始化 LeanCloud
try {
  
  AV.init({
    appId: "2wNgIGj8UmE5AAQRTtIBZ4Mn-gzGzoHsz",
    appKey: "gMFzQ0eRohuOkA8QcewcUjGA",
    serverURL: "https://2wngigj8.lc-cn-n1-shared.com"
  });
  console.log('LeanCloud 初始化成功');
  
} catch (error) {
  console.error('LeanCloud 初始化失败:', error);
}

document.addEventListener('DOMContentLoaded', function() {
  const likeButton = document.querySelector('.like-button');
  const likeCount = document.querySelector('.like-count');
  const path = likeButton.dataset.path;
  
  // 检查是否已经点赞过
  function hasLiked() {
    const likedPosts = JSON.parse(localStorage.getItem('likedPosts') || '[]');
    return likedPosts.includes(path);
  }
  
  // 标记文章已点赞
  function markAsLiked() {
    const likedPosts = JSON.parse(localStorage.getItem('likedPosts') || '[]');
    likedPosts.push(path);
    localStorage.setItem('likedPosts', JSON.stringify(likedPosts));
    updateLikeButtonState(true);
  }
  
  // 取消文章点赞标记
  function unmarkAsLiked() {
    const likedPosts = JSON.parse(localStorage.getItem('likedPosts') || '[]');
    const index = likedPosts.indexOf(path);
    if (index > -1) {
      likedPosts.splice(index, 1);
      localStorage.setItem('likedPosts', JSON.stringify(likedPosts));
    }
    updateLikeButtonState(false);
  }
  
  // 更新按钮状态
  function updateLikeButtonState(isLiked) {
    requestAnimationFrame(() => {
      if (isLiked) {
        likeButton.classList.add('liked');
        likeButton.title = '点击取消点赞';
      } else {
        likeButton.classList.remove('liked');
        likeButton.title = '点赞';
      }
    });
  }
  
  // 查询当前文章的点赞数
  async function getLikes() {
    try {
      const query = new AV.Query('Likes');
      query.equalTo('path', path);
      const result = await query.first();
      console.log('查询结果:', result);
      if (!result) {
        const Like = AV.Object.extend('Likes');
        const newLike = new Like();
        newLike.set('path', path);
        newLike.set('count', 0);
        return newLike;
      }
      return result;
    } catch (error) {
      console.error('获取点赞数失败:', error);
      return null;
    }
  }
  
  // 更新点赞显示
  async function updateLikeCount() {
    try {
      const like = await getLikes();
      if (like) {
        const count = like.get('count') || 0;
        console.log('当前点赞数:', count);
        requestAnimationFrame(() => {
          likeCount.textContent = count;
        });
      }
    } catch (error) {
      console.error('更新点赞显示失败:', error);
    }
  }
  
  // 处理点赞事件
  async function handleLike(event) {
    // 阻止默认行为和冒泡
    event.preventDefault();
    event.stopPropagation();
    
    const isLiked = hasLiked();
    console.log('当前点赞状态:', isLiked);
    
    try {
      let like = await getLikes();
      if (!like) {
        console.error('无法获取点赞对象');
        return;
      }
      
      if (isLiked) {
        // 取消点赞前检查当前点赞数
        const currentCount = like.get('count');
        if (currentCount > 0) {
          like.increment('count', -1);
          await like.save();
          unmarkAsLiked();
        } else {
          console.warn('点赞数已经为0，无法继续减少');
          unmarkAsLiked();
          return;
        }
      } else {
        // 添加点赞
        like.increment('count');
        await like.save();
        markAsLiked();
      }
      
      const newCount = like.get('count');
      console.log('操作成功，新的点赞数:', newCount);
      requestAnimationFrame(() => {
        likeCount.textContent = newCount;
      });
      
    } catch (error) {
      console.error('操作失败:', error);
    }
  }
  
  // 绑定点击和触摸事件
  likeButton.addEventListener('click', handleLike);
  likeButton.addEventListener('touchend', handleLike);
  console.log('点赞按钮事件绑定成功');
  
  // 防止触摸滚动
  likeButton.addEventListener('touchstart', (e) => e.preventDefault());
  likeButton.addEventListener('touchmove', (e) => e.preventDefault());
  
  // 初始化
  updateLikeCount();
  updateLikeButtonState(hasLiked());
});
</script> 

<div class="post-toc">
  <div class="toc-toggle">
    <i class="fas fa-chevron-left"></i>
  </div>
  <div class="post-toc-content">
    <h2>文章目录</h2>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%98%E6%98%AF%E5%A4%84%E7%90%86%E8%BF%99%E4%B8%AA%E6%96%B9%E7%A8%8B"><span class="toc-text">还是处理这个方程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E4%BC%B4%E9%9A%8F%E7%AE%97%E5%AD%90"><span class="toc-text">自伴随算子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%96%E8%AE%B8%E5%AD%98%E5%9C%A8%E2%80%9C%E6%82%96%E8%AE%BA%E2%80%9D"><span class="toc-text">或许存在“悖论”</span></a></li></ol>
  </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const tocToggle = document.querySelector('.toc-toggle');
  const postToc = document.querySelector('.post-toc');
  const tocLinks = document.querySelectorAll('.toc-link');
  const headers = document.querySelectorAll('article h1[id], article h2[id], article h3[id], article h4[id], article h5[id], article h6[id]');
  let activeLink = null;
  let isScrolling = false;
  
  // 检测是否是移动设备
  const isMobile = window.matchMedia('(max-width: 768px)').matches;
  
  // 切换目录显示/隐藏
  tocToggle.addEventListener('click', function() {
    postToc.classList.toggle('toc-hidden');
    tocToggle.classList.toggle('toc-toggle-hidden');
    
    // 在移动端，点击后立即应用样式
    if (isMobile) {
      requestAnimationFrame(() => {
        tocToggle.querySelector('i').style.color = postToc.classList.contains('toc-hidden') ? '#F03838' : '';
      });
    }
  });

  // 点击目录项平滑滚动
  tocLinks.forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const targetId = decodeURIComponent(link.getAttribute('href')).slice(1);
      const targetElement = document.getElementById(targetId);
      if (targetElement) {
        isScrolling = true;
        const offset = 80; // 头部固定导航的高度
        const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset - offset;
        
        window.scrollTo({
          top: targetPosition,
          behavior: 'smooth'
        });

        // 更新激活状态
        if (activeLink) {
          activeLink.classList.remove('active');
        }
        link.classList.add('active');
        activeLink = link;

        // 滚动结束后重置标志
        setTimeout(() => {
          isScrolling = false;
        }, 1000);
      }
    });
  });

  // 滚动时高亮当前目录项
  function updateActiveLink() {
    if (isScrolling) return; // 如果是点击导航引起的滚动，不更新高亮

    let currentSection = '';
    let minDistance = Infinity;
    const scrollPosition = window.scrollY + 100; // 考虑顶部偏移

    headers.forEach(header => {
      const distance = Math.abs(header.getBoundingClientRect().top);
      if (distance < minDistance) {
        minDistance = distance;
        currentSection = '#' + header.id;
      }
    });

    if (activeLink) {
      activeLink.classList.remove('active');
    }
    
    tocLinks.forEach(link => {
      if (decodeURIComponent(link.getAttribute('href')) === currentSection) {
        link.classList.add('active');
        activeLink = link;
        
        // 确保当前项在视图中
        const tocContainer = document.querySelector('.post-toc');
        const linkRect = link.getBoundingClientRect();
        const containerRect = tocContainer.getBoundingClientRect();
        
        if (linkRect.bottom > containerRect.bottom || linkRect.top < containerRect.top) {
          link.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'nearest'
          });
        }
      }
    });
  }

  // 使用 requestAnimationFrame 优化滚动事件
  let ticking = false;
  window.addEventListener('scroll', () => {
    if (!ticking) {
      window.requestAnimationFrame(() => {
        updateActiveLink();
        ticking = false;
      });
      ticking = true;
    }
  });

  // 初始化高亮
  updateActiveLink();
});
</script>


    
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2025 Fengyukongzhou
    
  </p>
</footer>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HSFDFFL0HT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-HSFDFFL0HT');
</script>

    
<script>
    var _hmt = _hmt || [];
    ( function () {
        var hm = document.createElement( "script" );
        hm.src = "https://hm.baidu.com/hm.js?b6d2577512b94cef71ed3db1d1ae70e4";
        var s = document.getElementsByTagName( "script" )[ 0 ];
        s.parentNode.insertBefore( hm, s );
    } )();
</script>

  </div>
</div>
</body>
</html>